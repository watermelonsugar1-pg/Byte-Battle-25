<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ASTD</title>
  <style>
    :root {
      --bg: #0f1220;
      --fg: #e8ecf1;
      --accent: #6cf3ff;
      --danger: #ff4d6d;
      --safe: #7cfc00;
    }

    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; height: 100%; background: var(--bg); color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }

    .wrap {
      display: grid; place-items: center; min-height: 100vh; padding: 20px;
    }

    .panel {
      width: 100%; max-width: 720px; border: 1px solid #1f2340; border-radius: 14px; overflow: hidden;
      background: linear-gradient(180deg, #12162a 0%, #0f1220 100%);
      box-shadow: 0 12px 32px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.04);
    }

    .header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 14px 16px; border-bottom: 1px solid #1f2340;
    }
    .title { font-weight: 700; letter-spacing: 0.3px; }
    .controls { opacity: 0.85; font-size: 0.95rem; }
    .controls kbd {
      background: #1a1f37; border: 1px solid #2a3056; color: var(--fg);
      padding: 2px 6px; border-radius: 6px; margin-right: 6px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
    }

    .canvas-wrap {
      position: relative; background: radial-gradient(1200px 500px at 50% -300px, #1b2242 0%, #0f1220 60%, #0b0e18 100%);
    }
    canvas { display: block; width: 100%; height: auto; image-rendering: crisp-edges; }

    .hud {
      position: absolute; top: 10px; left: 12px; right: 12px;
      display: flex; justify-content: space-between; align-items: center; pointer-events: none;
      font-weight: 600; text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }
    .chip {
      background: rgba(26,31,55,0.6); border: 1px solid #2a3056; padding: 6px 10px; border-radius: 10px;
    }
    .chip.safe { color: var(--safe); border-color: #2f523b; }
    .chip.danger { color: var(--danger); border-color: #5a2a36; }

    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center; text-align: center;
      backdrop-filter: blur(2px); transition: opacity 220ms ease;
    }
    .overlay.hidden { opacity: 0; pointer-events: none; }
    .overlay .card {
      background: rgba(15, 18, 32, 0.7); border: 1px solid #2a3056; border-radius: 16px; padding: 20px;
      box-shadow: 0 18px 44px rgba(0,0,0,0.45);
      max-width: 520px;
    }
    .overlay h2 { margin: 0 0 10px; }
    .overlay p { margin: 6px 0 12px; opacity: 0.9; }
    .overlay .btn {
      display: inline-block; margin-top: 6px; padding: 10px 16px; border-radius: 10px;
      border: 1px solid #2a3056; background: #1a1f37; color: var(--fg); cursor: pointer;
    }
    .overlay .btn:hover { filter: brightness(1.1); }
    .accent { color: var(--accent); }
    .footer {
      padding: 12px 16px; border-top: 1px solid #1f2340; font-size: 0.9rem; opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="header">
        <div class="title">Dodge — HTML5 Canvas Game</div>
        <div class="controls">
          <kbd>←</kbd><kbd>→</kbd><kbd>↑</kbd><kbd>↓</kbd> Move &nbsp;•&nbsp; <kbd>Enter</kbd> Restart
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="game" width="640" height="400" aria-label="Game canvas"></canvas>

        <div class="hud">
          <div class="chip"><span>Score:</span> <span id="score">0</span></div>
          <div class="chip"><span>Best:</span> <span id="best">0</span></div>
          <div class="chip danger" id="levelChip">Level: 1</div>
        </div>

        <div class="overlay" id="overlay">
          <div class="card">
            <h2>Ready to dodge?</h2>
            <p>Use the arrow keys to move the <span class="accent">blue square</span> and avoid falling blocks.</p>
            <p>Survive to increase your <strong>score</strong> and reach higher <strong>levels</strong>.</p>
            <button class="btn" id="startBtn">Start game</button>
          </div>
        </div>

        <div class="overlay hidden" id="gameOver">
          <div class="card">
            <h2>Game over</h2>
            <p>You collided with a block. Press <kbd>Enter</kbd> or click below to try again.</p>
            <p><strong>Final score:</strong> <span id="finalScore">0</span></p>
            <button class="btn" id="restartBtn">Restart</button>
          </div>
        </div>
      </div>

      <div class="footer">
        Tip: Tweaking speed and spawn rate in the code can make it easier or harder.
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const levelChip = document.getElementById('levelChip');
    const overlay = document.getElementById('overlay');
    const gameOver = document.getElementById('gameOver');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const finalScoreEl = document.getElementById('finalScore');

    const W = canvas.width;
    const H = canvas.height;

    // Player
    const player = {
      x: W/2 - 12, y: H - 60, w: 24, h: 24,
      speed: 3.2, color: '#6cf3ff'
    };

    // State
    let running = false;
    let score = 0;
    let best = Number(localStorage.getItem('bestScore') || 0);
    bestEl.textContent = best;
    let level = 1;

    // Obstacles
    const obstacles = [];
    const spawn = {
      interval: 950, // ms between spawns (decreases with level)
      last: 0
    };

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter'].includes(e.key)) e.preventDefault();
      if (e.key === 'Enter' && !running) startGame();
      keys.add(e.key);
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    startBtn.addEventListener('click', () => startGame());
    restartBtn.addEventListener('click', () => startGame());

    function startGame() {
      score = 0;
      level = 1;
      obstacles.length = 0;
      player.x = W/2 - player.w/2;
      player.y = H - 60;
      spawn.interval = 950;
      overlay.classList.add('hidden');
      gameOver.classList.add('hidden');
      running = true;
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function endGame() {
      running = false;
      finalScoreEl.textContent = score;
      gameOver.classList.remove('hidden');
      best = Math.max(best, score);
      localStorage.setItem('bestScore', best);
      bestEl.textContent = best;
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function rectsOverlap(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function spawnObstacle() {
      const w = 20 + Math.random() * 40;
      const h = 10 + Math.random() * 22;
      const x = Math.random() * (W - w);
      const speed = 1.2 + Math.random() * (0.6 + level * 0.3);
      obstacles.push({
        x, y: -h, w, h, vy: speed,
        color: `hsl(${Math.floor(340 + Math.random()*20)}, 75%, ${45 - level*1.5}%)`,
      });
    }

    function updatePlayer(dt) {
      let vx = 0, vy = 0;
      if (keys.has('ArrowLeft'))  vx -= player.speed;
      if (keys.has('ArrowRight')) vx += player.speed;
      if (keys.has('ArrowUp'))    vy -= player.speed;
      if (keys.has('ArrowDown'))  vy += player.speed;
      // Normalize diagonal speed
      if (vx !== 0 && vy !== 0) { vx *= 0.7071; vy *= 0.7071; }

      player.x = clamp(player.x + vx * dt, 0, W - player.w);
      player.y = clamp(player.y + vy * dt, 0, H - player.h);
    }

    function updateObstacles(dt) {
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.y += o.vy * dt * 60; // scale by ~60fps
        if (o.y > H + o.h) obstacles.splice(i, 1);
      }
    }

    function checkCollisions() {
      for (const o of obstacles) {
        if (rectsOverlap(player, o)) {
          endGame();
          return;
        }
      }
    }

    function drawBackground(t) {
      ctx.clearRect(0, 0, W, H);
      // Subtle grid
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.strokeStyle = '#4a4f7d';
      ctx.lineWidth = 1;
      const spacing = 32;
      for (let x = 0; x < W; x += spacing) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
      }
      for (let y = 0; y < H; y += spacing) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
      }
      ctx.restore();

      // Ambient glow
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = '#6cf3ff';
      ctx.beginPath();
      const glowY = H - 50 + Math.sin(t * 0.001) * 8;
      ctx.ellipse(W/2, glowY, W*0.45, 60, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawPlayer() {
      ctx.save();
      ctx.shadowColor = '#6cf3ff';
      ctx.shadowBlur = 14;
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.restore();
    }

    function drawObstacles() {
      ctx.save();
      ctx.shadowColor = '#ff4d6d';
      ctx.shadowBlur = 12;
      for (const o of obstacles) {
        ctx.fillStyle = o.color;
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
      ctx.restore();
    }

    function updateUI() {
      scoreEl.textContent = score;
      bestEl.textContent = best;
      levelChip.textContent = `Level: ${level}`;
      levelChip.className = 'chip ' + (level < 4 ? 'danger' : 'safe');
    }

    // Difficulty scaling
    function updateDifficulty(dt) {
      score += Math.floor(dt * 60); // scale score per frame time
      if (score < 200) level = 1;
      else if (score < 500) level = 2;
      else if (score < 900) level = 3;
      else if (score < 1400) level = 4;
      else level = 5;

      // Decrease spawn interval as level rises
      const target = Math.max(380, 950 - level * 120);
      spawn.interval += (target - spawn.interval) * 0.04; // smooth change
    }

    let lastTime = performance.now();
    let spawnTimer = 0;

    function loop(now) {
      if (!running) return;

      const dt = Math.min(0.033, (now - lastTime) / 1000); // cap dt at ~33ms
      lastTime = now;

      updatePlayer(dt);
      updateObstacles(dt);
      updateDifficulty(dt);

      spawnTimer += dt * 1000;
      if (spawnTimer >= spawn.interval) {
        spawnTimer = 0;
        spawnObstacle();
      }

      checkCollisions();

      drawBackground(now);
      drawObstacles();
      drawPlayer();
      updateUI();

      requestAnimationFrame(loop);
    }

    // Show overlay at start
    overlay.classList.remove('hidden');
  </script>
</body>
</html>
